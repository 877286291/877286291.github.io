{"meta":{"title":"Aurora博客","subtitle":"","description":"","author":"Aurora","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2021-08-05T02:24:22.805Z","updated":"2021-08-05T02:24:22.805Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-08-05T02:24:22.805Z","updated":"2021-08-05T02:24:22.804Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-08-05T02:24:22.804Z","updated":"2021-08-05T02:24:22.804Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2021-08-05T02:24:22.805Z","updated":"2021-08-05T02:24:22.805Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-08-05T02:24:22.802Z","updated":"2021-08-05T02:24:22.802Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"标签","date":"2021-08-05T02:24:22.807Z","updated":"2021-08-05T02:24:22.807Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-08-05T02:24:22.806Z","updated":"2021-08-05T02:24:22.806Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Springboot动态定时任务","slug":"Springboot动态定时任务","date":"2021-08-21T15:51:03.000Z","updated":"2021-08-21T17:03:22.136Z","comments":true,"path":"2021/08/21/Springboot动态定时任务/","link":"","permalink":"http://example.com/2021/08/21/Springboot%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","excerpt":"","text":"项目上遇到用户动态调整定时任务执行时间的需求，一开始是使用数据库存储任务执行时间的方式，每次执行任务之前会从数据库中重新读取一次配置信息，从而更改下次执行时间。这样会有一个问题，比如任务是每天10:00执行，用户在11点更新下次执行时间，但实际第二天是未生效的，要在下一个执行周期才会生效，不符合需求。最后使用反射实现。 1.编写反射工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public class BeanUtils &#123; public static Field findField(Class&lt;?&gt; clazz, String name) &#123; try &#123; return clazz.getField(name); &#125; catch (NoSuchFieldException ex) &#123; return findDeclaredField(clazz, name); &#125; &#125; public static Field findDeclaredField(Class&lt;?&gt; clazz, String name) &#123; try &#123; return clazz.getDeclaredField(name); &#125; catch (NoSuchFieldException ex) &#123; if (clazz.getSuperclass() != null) &#123; return findDeclaredField(clazz.getSuperclass(), name); &#125; return null; &#125; &#125; public static Method findMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... paramTypes) &#123; try &#123; return clazz.getMethod(methodName, paramTypes); &#125; catch (NoSuchMethodException ex) &#123; return findDeclaredMethod(clazz, methodName, paramTypes); &#125; &#125; public static Method findDeclaredMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... paramTypes) &#123; try &#123; return clazz.getDeclaredMethod(methodName, paramTypes); &#125; catch (NoSuchMethodException ex) &#123; if (clazz.getSuperclass() != null) &#123; return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes); &#125; return null; &#125; &#125; public static Object getProperty(Object obj, String name) throws NoSuchFieldException &#123; Object value; Field field = findField(obj.getClass(), name); if (field == null) &#123; throw new NoSuchFieldException(&quot;no such field [&quot; + name + &quot;]&quot;); &#125; boolean accessible = field.isAccessible(); field.setAccessible(true); try &#123; value = field.get(obj); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; field.setAccessible(accessible); return value; &#125; public static void setProperty(Object obj, String name, Object value) throws NoSuchFieldException &#123; Field field = findField(obj.getClass(), name); if (field == null) &#123; throw new NoSuchFieldException(&quot;no such field [&quot; + name + &quot;]&quot;); &#125; boolean accessible = field.isAccessible(); field.setAccessible(true); try &#123; field.set(obj, value); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; field.setAccessible(accessible); &#125; public static Map&lt;String, Object&gt; obj2Map(Object obj, Map&lt;String, Object&gt; map) &#123; if (map == null) &#123; map = new HashMap&lt;&gt;(); &#125; if (obj != null) &#123; try &#123; Class&lt;?&gt; clazz = obj.getClass(); do &#123; Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) &#123; int mod = field.getModifiers(); if (Modifier.isStatic(mod)) &#123; continue; &#125; boolean accessible = field.isAccessible(); field.setAccessible(true); map.put(field.getName(), field.get(obj)); field.setAccessible(accessible); &#125; clazz = clazz.getSuperclass(); &#125; while (clazz != null); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; return map; &#125; /** * 获得父类集合，包含当前class * * @param clazz * @return */ public static List&lt;Class&lt;?&gt;&gt; getSuperclassList(Class&lt;?&gt; clazz) &#123; List&lt;Class&lt;?&gt;&gt; clazzes = new ArrayList&lt;&gt;(3); clazzes.add(clazz); clazz = clazz.getSuperclass(); while (clazz != null) &#123; clazzes.add(clazz); clazz = clazz.getSuperclass(); &#125; return Collections.unmodifiableList(clazzes); &#125;&#125; 2.定时任务配置类 通过反射在程序运行时获取到定时任务对象，对其进行添加、删除、重置任务等操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879@Configuration@EnableSchedulingpublic class CompleteScheduleConfig implements SchedulingConfigurer &#123; private ScheduledTaskRegistrar taskRegistrar; private Set&lt;ScheduledFuture&lt;?&gt;&gt; scheduledFutures = null; private final Map&lt;String, ScheduledFuture&lt;?&gt;&gt; taskFutures = new ConcurrentHashMap&lt;&gt;(); @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123; this.taskRegistrar = taskRegistrar; &#125; @SuppressWarnings(&quot;unchecked&quot;) private Set&lt;ScheduledFuture&lt;?&gt;&gt; getScheduledFutures() &#123; if (scheduledFutures == null) &#123; try &#123; // spring版本不同选用不同字段scheduledFutures scheduledFutures = (Set&lt;ScheduledFuture&lt;?&gt;&gt;) BeanUtils.getProperty(taskRegistrar, &quot;scheduledTasks&quot;); &#125; catch (NoSuchFieldException e) &#123; throw new SchedulingException(&quot;not found scheduledFutures field.&quot;); &#125; &#125; return scheduledFutures; &#125; /** * 添加任务 */ public void addTriggerTask(String taskId, TriggerTask triggerTask) &#123; if (taskFutures.containsKey(taskId)) &#123; throw new SchedulingException(&quot;the taskId[&quot; + taskId + &quot;] was added.&quot;); &#125; TaskScheduler scheduler = taskRegistrar.getScheduler(); ScheduledFuture&lt;?&gt; future = scheduler.schedule(triggerTask.getRunnable(), triggerTask.getTrigger()); getScheduledFutures().add(future); taskFutures.put(taskId, future); &#125; /** * 取消任务 */ public void cancelTriggerTask(String taskId) &#123; ScheduledFuture&lt;?&gt; future = taskFutures.get(taskId); if (future != null) &#123; future.cancel(true); &#125; taskFutures.remove(taskId); getScheduledFutures().remove(future); &#125; /** * 重置任务 */ public void resetTriggerTask(String taskId, TriggerTask triggerTask) &#123; cancelTriggerTask(taskId); addTriggerTask(taskId, triggerTask); &#125; /** * 任务编号 */ public Set&lt;String&gt; taskIds() &#123; return taskFutures.keySet(); &#125; /** * 是否存在任务 */ public boolean hasTask(String taskId) &#123; return this.taskFutures.containsKey(taskId); &#125; /** * 任务调度是否已经初始化完成 */ public boolean inited() &#123; return this.taskRegistrar != null &amp;&amp; this.taskRegistrar.getScheduler() != null; &#125;&#125; 3.转换时间日期为cron表达式工具类123456789101112131415161718192021222324public class CronUtils &#123; /*** * 功能描述：日期转换cron表达式 * @param date * @return */ public static String formatDateByPattern(Date date) &#123; final SimpleDateFormat sdf = new SimpleDateFormat(&quot;ss mm HH dd MM ?&quot;); String formatTimeStr = null; if (Objects.nonNull(date)) &#123; formatTimeStr = sdf.format(date); &#125; return formatTimeStr; &#125; public static String formatTimeByPattern(Time time) &#123; final SimpleDateFormat sdf = new SimpleDateFormat(&quot;ss mm HH * * ?&quot;); String formatTimeStr = null; if (Objects.nonNull(time)) &#123; formatTimeStr = sdf.format(time); &#125; return formatTimeStr; &#125;&#125; 4.初始化定时任务 因为程序的定时任务信息是从数据库中获取的，所以我们要在springboot容器创建完成之后对定时任务进行初始化操作。 12345678910111213141516171819202122232425@Slf4j@Componentpublic class ContextRefreshedListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; private final CompleteScheduleConfig completeScheduleConfig; private final AlarmService alarmService; private final AlarmConfMapper alarmConfMapper; @Autowired public ContextRefreshedListener(AlarmService alarmService, AlarmConfMapper alarmConfMapper, CompleteScheduleConfig completeScheduleConfig) &#123; this.alarmService = alarmService; this.alarmConfMapper = alarmConfMapper; this.completeScheduleConfig = completeScheduleConfig; &#125; @Override public void onApplicationEvent(ContextRefreshedEvent event) &#123; log.debug(&quot;初始化定时任务&quot;); Time time = alarmConfMapper.queryEmployeeCheckTime(); if (ObjectUtils.isNotEmpty(time)) &#123; completeScheduleConfig.addTriggerTask(&quot;employeeCountAlarm&quot;, new TriggerTask( alarmService::employeeCountAlarm, new CronTrigger(CronUtils.formatTimeByPattern(time)))); &#125; &#125;&#125; 5.重置定时任务时间 接收到用户更新的任务执行时间之后，对当前任务进行重置。 12345678910111213141516@PutMapping(&quot;/conf/&#123;id&#125;&quot;) public BaseResponse&lt;String&gt; updateAlarmConf(@PathVariable Integer id, @RequestBody AlarmConfDto alarmConfDto) &#123; Boolean success = alarmService.updateAlarmConf(id, alarmConfDto); if (success) &#123; Time time = alarmConfMapper.queryEmployeeCheckTime(); if (ObjectUtils.isNotEmpty(time)) &#123; completeScheduleConfig.resetTriggerTask(&quot;employeeCountAlarm&quot;, new TriggerTask( alarmService::employeeCountAlarm, new CronTrigger(CronUtils.formatTimeByPattern(time)))); &#125; else &#123; completeScheduleConfig.cancelTriggerTask(&quot;employeeCountAlarm&quot;); &#125; return BaseResponse.ok(&quot;告警规则修改成功&quot;); &#125; return BaseResponse.ok(&quot;告警规则修改失败&quot;); &#125;","categories":[{"name":"springboot","slug":"springboot","permalink":"http://example.com/categories/springboot/"}],"tags":[{"name":"动态定时任务","slug":"动态定时任务","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"}]},{"title":"Docker+keepalived+nginx搭建高可用集群","slug":"Docker-keepalived-nginx搭建高可用集群","date":"2021-08-04T16:30:30.000Z","updated":"2021-08-21T17:03:02.771Z","comments":true,"path":"2021/08/05/Docker-keepalived-nginx搭建高可用集群/","link":"","permalink":"http://example.com/2021/08/05/Docker-keepalived-nginx%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/","excerpt":"","text":"1.Docker环境来模拟多服务器环境123456docker run -d --name web1 --privileged=true centos /usr/sbin/initdocker exec -it web1 /bin/bashdocker run -d --name web2 --privileged=true centos /usr/sbin/initdocker exec -it web2 /bin/bashdocker run -d --name webtest --privileged=true centos /usr/sbin/initdocker exec -it webtest /bin/bash –privileged=true：可以docker内真正拥有root权限 /usr/sbin/init：可以在docker内使用systemctl命令 2.安装nginx、keepalived、vim、net-tools、initscripts1yum install -y nginx keepalived vim net-tools initscripts initscripts：可以使用service命令 3.修改nginx默认html页面（方便查看主备切换）12cd /usr/share/nginx/htmlvim index.html 4.创建nginx进程检测脚本1234cd /etc/keepalivedtouch check_nginx.shchmod +x check_nginx.shvim check_nginx.sh 123456789#!/bin/bashA=`ps -C nginx --no-header | wc -l`if [ $A -eq 0 ];then /usr/sbin/nginx sleep 2 if [ `ps -C nginx --no-header | wc -l` -eq 0 ];then killall keepalived fifi 5.配置keepalived master节点配置 12345678910111213141516171819202122232425global_defs &#123; router_id LVS_DEVEL #节点名，一般使用默认的就可以&#125;vrrp_script chk_nginx &#123; script &quot;/etc/keepalived/check_nginx.sh&quot; #检测nginx脚本的路径 interval 2 #运行脚本的间隔时间 weight -20 #变更的权重&#125;vrrp_instance VI_1 &#123; state MASTER #此节点为MASTER，如果此节点down掉，再重启时，会立即抢占回主节点 #mcast_src_ip 172.17.0.2 本机ip，不声明则默认绑定本机ip interface eth0 #绑定的网卡，可以通过ifconfig查看网卡信息 virtual_router_id 70 #虚拟路由标识，同一组的必须相同 priority 100 #权重 nopreempt #定义为非抢占式，因为多次主备切换对请求量大的服务器不太好 advert_int 1 #与组内其他节点发送心跳的间隔：s virtual_ipaddress &#123; 172.17.0.200 &#125; #绑定的虚拟ip组 track_script &#123; chk_nginx &#125; #执行前面声明的脚本&#125; backup节点配置 123456789101112131415161718192021222324global_defs &#123; router_id LVS_DEVEL #节点名，一般使用默认的就可以&#125;vrrp_script chk_nginx &#123; script &quot;/etc/keepalived/check_nginx.sh&quot; #检测nginx脚本的路径 interval 2 #运行脚本的间隔时间 weight -20 #变更的权重&#125;vrrp_instance VI_1 &#123; state BACKUP #此节点为backup # mcast_src_ip 172.17.0.3 本机ip，不声明则默认绑定本机ip interface eth0 #绑定的网卡，可以通过ifconfig查看网卡信息 virtual_router_id 70 #虚拟路由标识，同一组的必须相同 priority 90 #权重，备节点的权重要比主节点小 advert_int 1 #与组内其他节点发送心跳的间隔：s。组内间隔必须相同 virtual_ipaddress &#123; 172.17.0.200 &#125; #绑定的虚拟ip组 track_script &#123; chk_nginx &#125; #执行前面声明的脚本&#125; 6.测试 启动web1、web2内的nginx及keepalived服务 12nginxsystemctl start keepalived 查看虚拟ip是否绑定在master节点 1ip a 使用webtest容器作为客户端访问nginx服务 1curl 172.17.0.200 停止web1容器，模拟宕机。再次访问nginx服务，成功迁移到backup节点","categories":[{"name":"HA","slug":"HA","permalink":"http://example.com/categories/HA/"}],"tags":[{"name":"高可用","slug":"高可用","permalink":"http://example.com/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"}]}],"categories":[{"name":"springboot","slug":"springboot","permalink":"http://example.com/categories/springboot/"},{"name":"HA","slug":"HA","permalink":"http://example.com/categories/HA/"}],"tags":[{"name":"动态定时任务","slug":"动态定时任务","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"name":"高可用","slug":"高可用","permalink":"http://example.com/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"}]}