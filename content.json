{"meta":{"title":"Aurora博客","subtitle":"","description":"","author":"Aurora","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-12-09T07:06:11.162Z","updated":"2021-08-05T02:24:22.802Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"书单","date":"2021-12-09T07:06:11.162Z","updated":"2021-08-05T02:24:22.804Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-12-09T07:06:11.162Z","updated":"2021-08-05T02:24:22.804Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2021-12-09T07:06:11.162Z","updated":"2021-08-05T02:24:22.805Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-12-09T07:06:11.162Z","updated":"2021-08-05T02:24:22.805Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-12-09T07:06:11.159Z","updated":"2021-08-05T02:24:22.806Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-12-09T07:06:11.162Z","updated":"2021-08-05T02:24:22.807Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MAC配置静态IP卡死","slug":"MAC配置静态IP卡死","date":"2021-12-22T07:13:47.000Z","updated":"2021-12-22T07:19:28.194Z","comments":true,"path":"2021/12/22/MAC配置静态IP卡死/","link":"","permalink":"http://example.com/2021/12/22/MAC%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%8D%A1%E6%AD%BB/","excerpt":"","text":"问题描述 macos上打开网络偏好设置想要设置静态ip时,光标放到输入框内就出现卡死情况,导致无法对ip地址,子网掩码等进行修改 解决方案12345678910// 获取网络设备名称networksetup -listallnetworkservices// An asterisk (*) denotes that a network service is disabled.// Wi-Fi// USB 10/100/1000 LAN// iPhone USB// Thunderbolt Bridge// 设置静态ip: networksetup -setmanual 设备名称 ip 子网掩码 网关networksetup -setmanual &quot;USB 10/100/1000 LAN&quot; 192.168.0.150 255.255.255.0 192.168.0.1","categories":[{"name":"util","slug":"util","permalink":"http://example.com/categories/util/"}],"tags":[{"name":"常见问题","slug":"常见问题","permalink":"http://example.com/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"}]},{"title":"SSH Socks5隧道代理","slug":"SSH-Socks5隧道代理","date":"2021-12-22T07:03:31.000Z","updated":"2021-12-22T07:14:56.144Z","comments":true,"path":"2021/12/22/SSH-Socks5隧道代理/","link":"","permalink":"http://example.com/2021/12/22/SSH-Socks5%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86/","excerpt":"","text":"1ssh -D 1337 -f -C -q -N user@remote -p 2222 -D 表示本地端口转发，当监听到此端口有连接时，此连接中的数据将通过安全隧道转发到server端，目前支持socks4和socks5协议 -f请求ssh在工作在后台模式。该选项隐含了”-n”选项，所以标准输入将变为/dev/null -C请求会话间的数据压缩传递。对于网络缓慢的主机，压缩对连接有所提升。但对网络流畅的主机来说，压缩只会更糟糕 -q静默模式。大多数警告信息将不输出 -N明确表示不执行远程命令。仅作端口转发时比较有用 -p指明端口号，如果是默认22端口，可以省略该参数 代理地址为socks5://127.0.0.1:1337","categories":[{"name":"util","slug":"util","permalink":"http://example.com/categories/util/"}],"tags":[{"name":"常见问题","slug":"常见问题","permalink":"http://example.com/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"}]},{"title":"MySQL8.0 MGR多主集群","slug":"MySQL8-0-MGR多主集群","date":"2021-08-22T15:11:29.000Z","updated":"2021-08-22T17:35:53.442Z","comments":true,"path":"2021/08/22/MySQL8-0-MGR多主集群/","link":"","permalink":"http://example.com/2021/08/22/MySQL8-0-MGR%E5%A4%9A%E4%B8%BB%E9%9B%86%E7%BE%A4/","excerpt":"","text":"多主集群实验环境 ip server-id db-port mgr-port node 172.10.0.2 100 3306 3308 master1 172.10.0.3 101 3306 3308 master2 1.集群环境配置1234567891011# 拉取MySQL镜像docker pull ubuntu/mysql:latest# 创建docker网络docker network create --subnet=172.10.0.0/24 mysql-network# 启动master1节点docker run -d --name mysql-master1 -e TZ=UTC -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root --net=mysql-network ubuntu/mysql:latest# 启动master2节点docker run -d --name mysql-master2 -e TZ=UTC -p 13307:3306 -e MYSQL_ROOT_PASSWORD=root --net=mysql-network ubuntu/mysql:latest 2.MGR配置12345# 进入容器master1docker exec -it mysql-master1 /bin/bash# 连接MySQL数据库mysql -uroot -p 1234# 安装mgr插件mysql&gt; install PLUGIN group_replication SONAME &#x27;group_replication.so&#x27;;# 查看插件是否安装成功mysql&gt; show plugins; 1234567891011121314151617181920212223242526272829303132333435363738# 修改master1 MySQL配置文件apt update &amp;&amp; apt install vim -y &amp;&amp; vim /etc/mysql/my.cnf# 修改如下[mysqld]pid-file = /var/run/mysqld/mysqld.pidsocket = /var/run/mysqld/mysqld.sockdatadir = /var/lib/mysqlsecure-file-priv= NULLgtid_mode=onenforce-gtid-consistency=onbinlog_format=row# 唯一值，每个节点应设置不同的值server-id = 100transaction_isolation = READ-COMMITTEDlog-slave-updates=1binlog_checksum=NONEmaster_info_repository=TABLErelay_log_info_repository=TABLEtransaction_write_set_extraction = XXHASH64# 当前组名称，Linux可以通过uuidgen生成。组内所有成员必须填写同一个值loose-group_replication_group_name = &#x27;1080E4E6-6245-410E-9D91-B1F07E289D0D&#x27;# ip白名单,默认只添加127.0.0.1,不会允许来自外部主机的连接,按需安全设置loose-group_replication_ip_whitelist = &#x27;172.10.0.0/24&#x27;# 是否随服务器启动而自动启动组复制loose-group_replication_start_on_boot = OFF# 本机地址:mgr端口loose-group_replication_local_address = &#x27;172.10.0.2:3308&#x27;# 组内成员地址:mgr端口loose-group_replication_group_seeds = &#x27;172.10.0.2:3308,172.10.0.3:3308&#x27;# 引导模式，首次搭建MGR或重建MGR时使用，组内只需要一台开启loose-group_replication_bootstrap_group = OFF# on为单主模式，off为多主模式loose-group_replication_single_primary_mode = off# 多主需开启强制检查loose-group_replication_enforce_update_everywhere_checks = on# Custom config should go here!includedir /etc/mysql/conf.d/ 12345# 进入容器master2docker exec -it mysql-master2 /bin/bash# 连接MySQL数据库mysql -uroot -p 安装MGR插件略，和上述master1节点安装方式一致 123456789101112131415161718192021222324252627282930# 修改master2 MySQL配置文件vim /etc/mysql/my.cnf# 修改如下[mysqld]pid-file = /var/run/mysqld/mysqld.pidsocket = /var/run/mysqld/mysqld.sockdatadir = /var/lib/mysqlsecure-file-priv= NULLgtid_mode=onenforce-gtid-consistency=onbinlog_format=row# 唯一值，每个节点应设置不同的值server-id = 101transaction_isolation = READ-COMMITTEDlog-slave-updates=1binlog_checksum=NONEmaster_info_repository=TABLErelay_log_info_repository=TABLEtransaction_write_set_extraction = XXHASH64loose-group_replication_group_name = &#x27;1080E4E6-6245-410E-9D91-B1F07E289D0D&#x27;loose-group_replication_ip_whitelist = &#x27;172.10.0.0/24&#x27;loose-group_replication_start_on_boot = OFFloose-group_replication_local_address = &#x27;172.10.0.3:3308&#x27;loose-group_replication_group_seeds = &#x27;172.10.0.2:3308,172.10.0.3:3308&#x27;loose-group_replication_bootstrap_group = OFFloose-group_replication_single_primary_mode = offloose-group_replication_enforce_update_everywhere_checks = on# Custom config should go here!includedir /etc/mysql/conf.d/ 3.启动MGR集群1234567891011121314151617181920212223# master1节点执行下述命令# 临时设置为引导模式，初始化集群，其他节点忽略这一步mysql&gt; SET GLOBAL group_replication_bootstrap_group=ON;# 创建用于同步数据的用户，集群中每一个节点都要做mysql&gt; CREATE USER &#x27;sroot&#x27;@&#x27;%&#x27; IDENTIFIED WITH sha256_password BY &#x27;123123&#x27;;# 用户授权mysql&gt; grant REPLICATION SLAVE on *.* to &#x27;sroot&#x27;@&#x27;%&#x27; with grant option;#清空所有旧的GTID信息,避免冲突mysql&gt; reset master;#创建同步规则认证信息,就是刚才授权的那个用户,和一般的主从规则写法不太一样mysql&gt; CHANGE MASTER TO MASTER_USER=&#x27;sroot&#x27;, MASTER_PASSWORD=&#x27;123123&#x27; FOR CHANNEL &#x27;group_replication_recovery&#x27;;#启动MGRmysql&gt; start group_replication;#查看是否启动成功,看到online就是成功了mysql&gt; SELECT * FROM performance_schema.replication_group_members;+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+| CHANNEL_NAME | MEMBER_ID | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE | MEMBER_ROLE | MEMBER_VERSION |+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+| group_replication_applier | 6eada4c6-034b-11ec-ad7e-0242ac0a0002 | 34ed0726e911 | 3306 | ONLINE | PRIMARY | 8.0.26 |+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+1 row in set (0.00 sec)# 成功后关闭引导mysql&gt; SET GLOBAL group_replication_bootstrap_group=OFF; 1234567891011121314# master2节点执行下述命令mysql&gt; CREATE USER &#x27;sroot&#x27;@&#x27;%&#x27; IDENTIFIED WITH sha256_password BY &#x27;123123&#x27;;mysql&gt; grant REPLICATION SLAVE on *.* to &#x27;sroot&#x27;@&#x27;%&#x27; with grant option;mysql&gt; reset master;mysql&gt; CHANGE MASTER TO MASTER_USER=&#x27;sroot&#x27;, MASTER_PASSWORD=&#x27;123123&#x27; FOR CHANNEL &#x27;group_replication_recovery&#x27;;mysql&gt; start group_replication;mysql&gt; SELECT * FROM performance_schema.replication_group_members;+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+| CHANNEL_NAME | MEMBER_ID | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE | MEMBER_ROLE | MEMBER_VERSION |+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+| group_replication_applier | 3cdb4148-0368-11ec-a98c-0242ac0a0002 | ac552a48ba6a | 3306 | ONLINE | PRIMARY | 8.0.26 || group_replication_applier | 42d5b286-0368-11ec-be8c-0242ac0a0003 | 678d06c71f3b | 3306 | ONLINE | PRIMARY | 8.0.26 |+---------------------------+--------------------------------------+--------------+-------------+--------------+-------------+----------------+2 rows in set (0.01 sec) 4.测试验证12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# master1中创建数据库mysql&gt; create database test;# master2中查看数据库mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys || test |+--------------------+5 rows in set (0.01 sec)# 模拟宕机，停止容器master1docker stop mysql-master1# master2中建表并写入数据mysql&gt; use test;Database changedmysql&gt; create table student -&gt; ( -&gt; id int primary key, -&gt; name varchar(20), -&gt; gender int, -&gt; age int -&gt; );Query OK, 0 rows affected (0.04 sec)mysql&gt; insert into student values(1,&#x27;tom&#x27;,1,23);Query OK, 1 row affected (0.01 sec)# 启动master1并进入容器docker start mysql-master1 &amp;&amp; docker exec -it mysql-master1 /bin/bash# 由于没有打开group_replication_start_on_boot，需手动启动组复制mysql&gt; start group_replication;mysql&gt; use test;Database changedmysql&gt; show tables;+----------------+| Tables_in_test |+----------------+| student |+----------------+1 row in set (0.01 sec)mysql&gt; select * from student;+----+------+--------+------+| id | name | gender | age |+----+------+--------+------+| 1 | tom | 1 | 23 |+----+------+--------+------+1 row in set (0.00 sec)","categories":[{"name":"HA","slug":"HA","permalink":"http://example.com/categories/HA/"}],"tags":[{"name":"高可用","slug":"高可用","permalink":"http://example.com/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"}]},{"title":"Springboot动态定时任务","slug":"Springboot动态定时任务","date":"2021-08-21T15:51:03.000Z","updated":"2021-08-21T17:03:22.136Z","comments":true,"path":"2021/08/21/Springboot动态定时任务/","link":"","permalink":"http://example.com/2021/08/21/Springboot%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","excerpt":"","text":"项目上遇到用户动态调整定时任务执行时间的需求，一开始是使用数据库存储任务执行时间的方式，每次执行任务之前会从数据库中重新读取一次配置信息，从而更改下次执行时间。这样会有一个问题，比如任务是每天10:00执行，用户在11点更新下次执行时间，但实际第二天是未生效的，要在下一个执行周期才会生效，不符合需求。最后使用反射实现。 1.编写反射工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public class BeanUtils &#123; public static Field findField(Class&lt;?&gt; clazz, String name) &#123; try &#123; return clazz.getField(name); &#125; catch (NoSuchFieldException ex) &#123; return findDeclaredField(clazz, name); &#125; &#125; public static Field findDeclaredField(Class&lt;?&gt; clazz, String name) &#123; try &#123; return clazz.getDeclaredField(name); &#125; catch (NoSuchFieldException ex) &#123; if (clazz.getSuperclass() != null) &#123; return findDeclaredField(clazz.getSuperclass(), name); &#125; return null; &#125; &#125; public static Method findMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... paramTypes) &#123; try &#123; return clazz.getMethod(methodName, paramTypes); &#125; catch (NoSuchMethodException ex) &#123; return findDeclaredMethod(clazz, methodName, paramTypes); &#125; &#125; public static Method findDeclaredMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... paramTypes) &#123; try &#123; return clazz.getDeclaredMethod(methodName, paramTypes); &#125; catch (NoSuchMethodException ex) &#123; if (clazz.getSuperclass() != null) &#123; return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes); &#125; return null; &#125; &#125; public static Object getProperty(Object obj, String name) throws NoSuchFieldException &#123; Object value; Field field = findField(obj.getClass(), name); if (field == null) &#123; throw new NoSuchFieldException(&quot;no such field [&quot; + name + &quot;]&quot;); &#125; boolean accessible = field.isAccessible(); field.setAccessible(true); try &#123; value = field.get(obj); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; field.setAccessible(accessible); return value; &#125; public static void setProperty(Object obj, String name, Object value) throws NoSuchFieldException &#123; Field field = findField(obj.getClass(), name); if (field == null) &#123; throw new NoSuchFieldException(&quot;no such field [&quot; + name + &quot;]&quot;); &#125; boolean accessible = field.isAccessible(); field.setAccessible(true); try &#123; field.set(obj, value); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; field.setAccessible(accessible); &#125; public static Map&lt;String, Object&gt; obj2Map(Object obj, Map&lt;String, Object&gt; map) &#123; if (map == null) &#123; map = new HashMap&lt;&gt;(); &#125; if (obj != null) &#123; try &#123; Class&lt;?&gt; clazz = obj.getClass(); do &#123; Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) &#123; int mod = field.getModifiers(); if (Modifier.isStatic(mod)) &#123; continue; &#125; boolean accessible = field.isAccessible(); field.setAccessible(true); map.put(field.getName(), field.get(obj)); field.setAccessible(accessible); &#125; clazz = clazz.getSuperclass(); &#125; while (clazz != null); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; return map; &#125; /** * 获得父类集合，包含当前class * * @param clazz * @return */ public static List&lt;Class&lt;?&gt;&gt; getSuperclassList(Class&lt;?&gt; clazz) &#123; List&lt;Class&lt;?&gt;&gt; clazzes = new ArrayList&lt;&gt;(3); clazzes.add(clazz); clazz = clazz.getSuperclass(); while (clazz != null) &#123; clazzes.add(clazz); clazz = clazz.getSuperclass(); &#125; return Collections.unmodifiableList(clazzes); &#125;&#125; 2.定时任务配置类 通过反射在程序运行时获取到定时任务对象，对其进行添加、删除、重置任务等操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879@Configuration@EnableSchedulingpublic class CompleteScheduleConfig implements SchedulingConfigurer &#123; private ScheduledTaskRegistrar taskRegistrar; private Set&lt;ScheduledFuture&lt;?&gt;&gt; scheduledFutures = null; private final Map&lt;String, ScheduledFuture&lt;?&gt;&gt; taskFutures = new ConcurrentHashMap&lt;&gt;(); @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123; this.taskRegistrar = taskRegistrar; &#125; @SuppressWarnings(&quot;unchecked&quot;) private Set&lt;ScheduledFuture&lt;?&gt;&gt; getScheduledFutures() &#123; if (scheduledFutures == null) &#123; try &#123; // spring版本不同选用不同字段scheduledFutures scheduledFutures = (Set&lt;ScheduledFuture&lt;?&gt;&gt;) BeanUtils.getProperty(taskRegistrar, &quot;scheduledTasks&quot;); &#125; catch (NoSuchFieldException e) &#123; throw new SchedulingException(&quot;not found scheduledFutures field.&quot;); &#125; &#125; return scheduledFutures; &#125; /** * 添加任务 */ public void addTriggerTask(String taskId, TriggerTask triggerTask) &#123; if (taskFutures.containsKey(taskId)) &#123; throw new SchedulingException(&quot;the taskId[&quot; + taskId + &quot;] was added.&quot;); &#125; TaskScheduler scheduler = taskRegistrar.getScheduler(); ScheduledFuture&lt;?&gt; future = scheduler.schedule(triggerTask.getRunnable(), triggerTask.getTrigger()); getScheduledFutures().add(future); taskFutures.put(taskId, future); &#125; /** * 取消任务 */ public void cancelTriggerTask(String taskId) &#123; ScheduledFuture&lt;?&gt; future = taskFutures.get(taskId); if (future != null) &#123; future.cancel(true); &#125; taskFutures.remove(taskId); getScheduledFutures().remove(future); &#125; /** * 重置任务 */ public void resetTriggerTask(String taskId, TriggerTask triggerTask) &#123; cancelTriggerTask(taskId); addTriggerTask(taskId, triggerTask); &#125; /** * 任务编号 */ public Set&lt;String&gt; taskIds() &#123; return taskFutures.keySet(); &#125; /** * 是否存在任务 */ public boolean hasTask(String taskId) &#123; return this.taskFutures.containsKey(taskId); &#125; /** * 任务调度是否已经初始化完成 */ public boolean inited() &#123; return this.taskRegistrar != null &amp;&amp; this.taskRegistrar.getScheduler() != null; &#125;&#125; 3.转换时间日期为cron表达式工具类123456789101112131415161718192021222324public class CronUtils &#123; /*** * 功能描述：日期转换cron表达式 * @param date * @return */ public static String formatDateByPattern(Date date) &#123; final SimpleDateFormat sdf = new SimpleDateFormat(&quot;ss mm HH dd MM ?&quot;); String formatTimeStr = null; if (Objects.nonNull(date)) &#123; formatTimeStr = sdf.format(date); &#125; return formatTimeStr; &#125; public static String formatTimeByPattern(Time time) &#123; final SimpleDateFormat sdf = new SimpleDateFormat(&quot;ss mm HH * * ?&quot;); String formatTimeStr = null; if (Objects.nonNull(time)) &#123; formatTimeStr = sdf.format(time); &#125; return formatTimeStr; &#125;&#125; 4.初始化定时任务 因为程序的定时任务信息是从数据库中获取的，所以我们要在springboot容器创建完成之后对定时任务进行初始化操作。 12345678910111213141516171819202122232425@Slf4j@Componentpublic class ContextRefreshedListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; private final CompleteScheduleConfig completeScheduleConfig; private final AlarmService alarmService; private final AlarmConfMapper alarmConfMapper; @Autowired public ContextRefreshedListener(AlarmService alarmService, AlarmConfMapper alarmConfMapper, CompleteScheduleConfig completeScheduleConfig) &#123; this.alarmService = alarmService; this.alarmConfMapper = alarmConfMapper; this.completeScheduleConfig = completeScheduleConfig; &#125; @Override public void onApplicationEvent(ContextRefreshedEvent event) &#123; log.debug(&quot;初始化定时任务&quot;); Time time = alarmConfMapper.queryEmployeeCheckTime(); if (ObjectUtils.isNotEmpty(time)) &#123; completeScheduleConfig.addTriggerTask(&quot;employeeCountAlarm&quot;, new TriggerTask( alarmService::employeeCountAlarm, new CronTrigger(CronUtils.formatTimeByPattern(time)))); &#125; &#125;&#125; 5.重置定时任务时间 接收到用户更新的任务执行时间之后，对当前任务进行重置。 12345678910111213141516@PutMapping(&quot;/conf/&#123;id&#125;&quot;) public BaseResponse&lt;String&gt; updateAlarmConf(@PathVariable Integer id, @RequestBody AlarmConfDto alarmConfDto) &#123; Boolean success = alarmService.updateAlarmConf(id, alarmConfDto); if (success) &#123; Time time = alarmConfMapper.queryEmployeeCheckTime(); if (ObjectUtils.isNotEmpty(time)) &#123; completeScheduleConfig.resetTriggerTask(&quot;employeeCountAlarm&quot;, new TriggerTask( alarmService::employeeCountAlarm, new CronTrigger(CronUtils.formatTimeByPattern(time)))); &#125; else &#123; completeScheduleConfig.cancelTriggerTask(&quot;employeeCountAlarm&quot;); &#125; return BaseResponse.ok(&quot;告警规则修改成功&quot;); &#125; return BaseResponse.ok(&quot;告警规则修改失败&quot;); &#125;","categories":[{"name":"springboot","slug":"springboot","permalink":"http://example.com/categories/springboot/"}],"tags":[{"name":"动态定时任务","slug":"动态定时任务","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"}]},{"title":"Docker+keepalived+nginx搭建高可用集群","slug":"Docker-keepalived-nginx搭建高可用集群","date":"2021-08-04T16:30:30.000Z","updated":"2021-08-22T12:30:17.983Z","comments":true,"path":"2021/08/05/Docker-keepalived-nginx搭建高可用集群/","link":"","permalink":"http://example.com/2021/08/05/Docker-keepalived-nginx%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/","excerpt":"","text":"1.Docker环境来模拟多服务器环境123456docker run -d --name web1 --privileged=true centos /usr/sbin/initdocker exec -it web1 /bin/bashdocker run -d --name web2 --privileged=true centos /usr/sbin/initdocker exec -it web2 /bin/bashdocker run -d --name webtest --privileged=true centos /usr/sbin/initdocker exec -it webtest /bin/bash –privileged=true：可以docker内真正拥有root权限 /usr/sbin/init：可以在docker内使用systemctl命令 2.安装nginx、keepalived、vim、net-tools、initscripts1yum install -y nginx keepalived vim net-tools initscripts initscripts：可以使用service命令 3.修改nginx默认html页面（方便查看主备切换）12cd /usr/share/nginx/htmlvim index.html 4.创建nginx进程检测脚本1234cd /etc/keepalivedtouch check_nginx.shchmod +x check_nginx.shvim check_nginx.sh 123456789#!/bin/bashA=`ps -C nginx --no-header | wc -l`if [ $A -eq 0 ];then /usr/sbin/nginx sleep 2 if [ `ps -C nginx --no-header | wc -l` -eq 0 ];then killall keepalived fifi 5.配置keepalived master节点配置 12345678910111213141516171819202122232425global_defs &#123; router_id LVS_DEVEL #节点名，一般使用默认的就可以&#125;vrrp_script chk_nginx &#123; script &quot;/etc/keepalived/check_nginx.sh&quot; #检测nginx脚本的路径 interval 2 #运行脚本的间隔时间 weight -20 #变更的权重&#125;vrrp_instance VI_1 &#123; state MASTER #此节点为MASTER，如果此节点down掉，再重启时，会立即抢占回主节点 #mcast_src_ip 172.17.0.2 本机ip，不声明则默认绑定本机ip interface eth0 #绑定的网卡，可以通过ifconfig查看网卡信息 virtual_router_id 70 #虚拟路由标识，同一组的必须相同 priority 100 #权重 nopreempt #定义为非抢占式，因为多次主备切换对请求量大的服务器不太好 advert_int 1 #与组内其他节点发送心跳的间隔：s virtual_ipaddress &#123; 172.17.0.200 &#125; #绑定的虚拟ip组 track_script &#123; chk_nginx &#125; #执行前面声明的脚本&#125; backup节点配置 123456789101112131415161718192021222324global_defs &#123; router_id LVS_DEVEL #节点名，一般使用默认的就可以&#125;vrrp_script chk_nginx &#123; script &quot;/etc/keepalived/check_nginx.sh&quot; #检测nginx脚本的路径 interval 2 #运行脚本的间隔时间 weight -20 #变更的权重&#125;vrrp_instance VI_1 &#123; state BACKUP #此节点为backup # mcast_src_ip 172.17.0.3 本机ip，不声明则默认绑定本机ip interface eth0 #绑定的网卡，可以通过ifconfig查看网卡信息 virtual_router_id 70 #虚拟路由标识，同一组的必须相同 priority 90 #权重，备节点的权重要比主节点小 advert_int 1 #与组内其他节点发送心跳的间隔：s。组内间隔必须相同 virtual_ipaddress &#123; 172.17.0.200 &#125; #绑定的虚拟ip组 track_script &#123; chk_nginx &#125; #执行前面声明的脚本&#125; 6.测试 启动web1、web2内的nginx及keepalived服务 12nginxsystemctl start keepalived 查看虚拟ip是否绑定在master节点 1ip a 使用webtest容器作为客户端访问nginx服务 1curl 172.17.0.200 停止web1容器，模拟宕机。再次访问nginx服务，成功迁移到backup节点","categories":[{"name":"HA","slug":"HA","permalink":"http://example.com/categories/HA/"}],"tags":[{"name":"高可用","slug":"高可用","permalink":"http://example.com/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"}]}],"categories":[{"name":"util","slug":"util","permalink":"http://example.com/categories/util/"},{"name":"HA","slug":"HA","permalink":"http://example.com/categories/HA/"},{"name":"springboot","slug":"springboot","permalink":"http://example.com/categories/springboot/"}],"tags":[{"name":"常见问题","slug":"常见问题","permalink":"http://example.com/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"name":"高可用","slug":"高可用","permalink":"http://example.com/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"},{"name":"动态定时任务","slug":"动态定时任务","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"}]}